#!/usr/bin/python3

import os
import sys
import json
from powered_g import powercharged

if not os.path.isdir('.git'):
    print('This is not a git repository')
    exit()

script_path = os.path.dirname(os.path.realpath(__file__))
if not os.path.isfile(script_path + '/update.log'):
    os.popen("date >> ~/.giti/update.log")

updatelog = open(script_path + '/update.log', 'r').readlines()

commands_list = []
description = {}
command_input = {}
message = {}

if os.path.isfile("./.git/index.lock"):
    os.remove("./.git/index.lock")
git_status = os.popen('git status -s').readlines()


def search_in_status(file_name):
    for entry in git_status:
        comp = entry[3:]
        if file_name in comp or comp in file_name:
            return True
    return False


def is_a_command(command):
    global commands_list
    if command in commands_list:
        return True
    else:
        return False


def git_file():
    global git_status
    choice_loop = True
    while choice_loop:
        print("0. Exit")
        for line in git_status:
            print(f"{git_status.index(line) + 1}: {line[3:]}")
        choice = input("Which file do you want to commit? ")
        try:
            choice = int(choice) - 1
        except:
            print("Invalid input.")
            continue
        # check if the choice is valid
        if choice < -1 or choice >= len(git_status):
            print("Invalid choice")
        elif choice == -1:
            return False
        else:
            return git_status[choice][3:]


def load_commands():
    global commands_list, description, command_input, message
    file_data = json.load(open(script_path + '/commands/commands.json'))
    for entry in file_data:
        command_name = entry['command']
        if isinstance(command_name, list):
            for command in command_name:
                commands_list.append(command)
                description[command] = entry['description']
                command_input[command] = entry['input']
                message[command] = entry['message']
        else:
            commands_list.append(command_name)
            description[command_name] = entry['description']
            command_input[command_name] = entry['input']
            message[command_name] = entry['message']


def file_picker():
    file = git_file()
    if file == False:
        return 0
    else:
        return file


def command_interpreter(command, file):
    global command_input, message
    inputs = command_input[command]
    msg = message[command]
    answer = []
    for qs in inputs:
        answer.append(input(f"{qs}: "))
    for x, item in enumerate(answer):
        msg = msg.replace(f"${x + 1}", item)
    msg = f"{file}:\n\t{msg}\n"
    return msg


def file_by_file(command, file=0):
    if file == 0:
        file = file_picker()
    if file == 0:
        print("Exiting...")
        return 0
    msg = command_interpreter(command, file)
    os.wait()
    os.popen(f"git add *{file}")
    return msg


def main(params):
    global commands_list, description, command_input, message

    if len(params) == 1 or params[1] == "powercharged":
        powercharged()
    elif is_a_command(params[1]) and len(params) < 4:
        command = params[1]
        if len(params) == 2:
            msg = file_by_file(command)
        elif len(params) == 3 and search_in_status(params[2]):
            msg = file_by_file(command, params[2])
        else:
            print("There was an error - Invalid Command")
            exit(1)
        if msg == 0:
            exit()
        commit_title = input("Commit title: ")
        final_msg = f":sparkles: {commit_title}\n" + msg
        os.wait()
        os.popen(f'git commit -m "{final_msg}"')
        print("Commit successful!")
    elif params[1] == 'help':
        print("Last updated: " + updatelog[0])
        print('''
        giti is a git commit interface that allows you to make commits without having to type them out.
        To use giti, type 'giti' followed by the command you want to run.
        The commands are:
        - powercharged (or none): a commit interface that allows you to make commits with extensive help.
        - help: displays this message.
        - update: Fetch an update from github
        ''')
        ch = input("Do you want to display the commit help ? y/n  ")
        if ch == "y" or ch == "yes":
            x = 0
            for command in commands_list:
                print(f'''- {command}: {description[command]}''')
                x += 1
                if x == 6:
                    x = 0
                    input("----------")
    elif params[1] == 'update':
        os.popen('cd ~/.giti / && git pull -q && cd -')
        os.popen('date > ~/.giti/update.log')
        print("Update successful!")


    elif params[1] == 'all':
        commit_message = input("Commit message: ") + ":card_file_box: "
        number_of_files = len(git_status)
        os.popen(f'git add .')
        os.wait()
        os.popen(f'git commit -m ":sparkles: For {number_of_files} files:\n\t{commit_message}"')

    elif is_a_command(params[1]) and len(params) >= 4:
        print("Multiple Files commit")
        files = []
        for file in params[2:]:
            if search_in_status(file):
                files.append(file)
            else:
                print(f"File {file} not found - Ignoring")
        if len(files) == 0:
            print("No files found - Exiting")
            exit(1)
        command = params[1]
        file = files.join("\n")
        msg = command_interpreter(command, file)
        commit_title = input("Commit title: ")
        final_msg = f":sparkles: {commit_title}\n" + msg
        os.wait()
        os.popen(f'git commit -m "{final_msg}"')
        print("Commit successful!")
    else:
        print("Command not found. Type 'giti help' for help.")


if __name__ == '__main__':
    load_commands()
    main(sys.argv)
